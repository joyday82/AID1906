回顧day03

1.進程間通信
    **管道通信 Pipe()  p.send() p.recv() 一端從管道發送 另一端就可以接收 可以發送所有數據類型
    當send是空recv就會阻塞
    一次發送的內容會被一次接收,連續發送五次就要調用五次才能接收
    **消息隊列Queue() q.get() q.put() 讀寫都會阻塞 消息隊列為空時 或滿時就會阻塞
    **共享內存Value() Array() 共享內存效率會高一點 但無法存大量的消息 第二次放消息會把第一次的覆蓋掉
             value是存單一值 Array是存一組值
    **信號量Semaphore() 生成一個控制量 acquire()消號一個消耗量 release()增加一個消耗量
                       消耗量為0時 acquire會阻塞
                       更多時候是把消耗量的數量當成一種資源 用來控制執行行為
2.threading線程 是一個運行過程,屬於進程的一部分,利用計算機的多核進行併發或並行執行
        它所消耗的資源是由進程提供
        一線程的退出不影響其他線程的執行 但如果在一個線程裡面調用exit那整個的進程都會退出
        **Thread()創建線程對象
            start()啟動線程
            join()回收線程
3.線程屬性 name is_alive() daemon
4.自定義線程類 簡單來說就是繼承thread重寫__init__,run
5.線程的同步互斥 為什麼需要呢？因為多個線程對共享資源(全局變數)的無序操錯有可能帶來數據的混亂
            就是加上阻塞,通過阻塞影響多個線程對共享量的操作順序來滿足邏輯需求

  同步互斥方法：Event() wait() set() clear()
              Lock() acquire() release()

  死鎖：由於上鎖造成程序阻塞無法繼續運行
       自己擁有一個條件又請求別人有的條件 雙方都不放手就造成阻塞
single cpu: 8.123857259750366
single io:single cpu: 6.730822801589966

process cpu: 9.802994966506958
process io: 4.545267581939697

Thread cpu: 6.557920455932617
Thread io: 4.022314548492432

以上可知 多進程提高運行效率 多線程

練習：根據fork多進程併發網路模型思路 完成基於process的多進程併發網路模型 process_server.py

ftp文件服務器
1.技術點確定
    併發模型：多進程 多線程都可以 先以多線程併發來做
    數據傳輸：tcp傳輸 下載文件耗時長
2.結構設計：類封裝
          基本文件操作功能封為類（查看 下載 上傳）
3.分析具體功能(功能模塊)
    有通信的話要先搭建網路通信模型
    查看文件列表(基本功能)
    下載文件
    上傳文件
    客戶端退出(服務端也要結束線程)
4.協議確定
    L
    Q
    G
    P
